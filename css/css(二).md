## 浮动的特性

1. 包裹性（包裹和自适应性）

   > 包裹：假设浮动元素父元素宽度200px,浮动元素的子元素是一个128px宽度的图片，则此时浮动元素宽度也为128px.
   >
   > 自适应性：如果子元素不只是一张图片，还有文字，则浮动元素自适应父元素的宽度，为200px

2. 块状化并格式化上下文

   > 元素的float属性值不为none,则其display的计算值就是block 或者 table

3. 破坏文档流

4. 没有任何margin合并

## 盒模型

1. 盒模型的组成大家肯定都懂，由里向外content,padding,border,margin.

2. 盒模型是有两种标准的，一个是标准模型，一个是IE模型。

   > 标准模型中，盒模型的宽高只是内容（content）的宽高
   >
   > IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。



## Css Sprite（优点）

1. 减少图片的字节。
2. 减少网页的http请求，从而大大的提高页面的性能。
3. 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。
4. 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。

> css background-position

## float和position一起用是什么效果

> float浮动与position同时使用并不会冲突，前者是使元素脱离标准流，浮动在文档流上；而后者是使元素相对自身的移动定位，虽浮动但占据原有位置。当两者同时使用时，不会发生冲突，反而使元素同时具有两者特性，即既可以相对自身移动定位，又可以浮动不占位置

## rem用过吗？做不同手机的适配怎么做？

[手机端页面自适应解决方案—rem布局进阶版](https://www.jianshu.com/p/985d26b40199)

## 为什么transform比margin的性能好

1. 主线程：用于计算css样式，页面布局等，将元素位置一个个的位图,然后将位图交给合成线程
2. 合成线程：将主线程传过来的各种位图绘制到屏幕上，在通知主线程更新页面可见或即将可见的位图。

原因：margin 每个一个像素的改变，主线程都是需要计算一次

，而transform 只需要提交一次的改变交给主线程

## 为什么要初始化Css的样式

> 因为各种浏览器的兼容性不同，不同浏览对有些标签的默认值是不同的，如果没对css初始化，不同页面往往会产生差异。