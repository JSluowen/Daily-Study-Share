## 说一下冒泡快排的原理

**快速排序**：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以[递归](https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695)进行，以此达到整个数据变成有序[序列](https://baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588)。

**冒泡排序**：从元素首位进行比较，依次比较相邻两个元素，如果从小到大排序，那么前面元素比后面大，就应该交换位置，相反，就不动。一轮比较下来，就能将最大的元素放在末尾。犹如冒泡一样。

## Heap排序方法的原理？复杂度？

堆排序（英语：Heapsort）是指利用[堆](https://baike.baidu.com/item/%E5%A0%86)这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

复杂度：O (nlogn)

## 几种常见的排序算法，手写

### 冒泡排序

> 从元素首位开始进行比较，依次比较相邻两个元素，如果从小到大排序，那么前面元素比后面大，就应该交换位置，相反，就不动。一轮比较下来，就能将最大的元素放在末尾。犹如冒泡一样

```javascript
function bubbleSort(data){
    var temp=0;
    for(var i=data.length;i>0;i--){
        for(var j=0;j<i-1;j++){
            if(data[j]>data[j+1]){
              temp=data[j];
              data[j]=data[j+1];
              data[j+1]=temp;
           }
        }
    }
   return data;
}
```

### 选择排序

> 它的工作原理是每一次从待排序的[数据元素](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313)中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。
>
> 时间复杂度:O(n^2)

```javascript
var arr = new Array(1, 3, 2, 8, 9, 1, 5);
function SelectionSort(arr) {
    if (arr == null || arr.length < 2) {
         return arr;
    }
    for (var i = 0; i < (arr.length - 1); i++) {
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        let temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

### 插入排序

> 插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起
>
> [时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1894057):O(n^2)

```javascript
//测试数组
var arr = new Array(1, 3, 2, 8, 9, 1, 5);
//插入排序
function InsertionSort(arr) {
    if (arr == null || arr.length < 2) {
        return arr;
    }
    for (let i = 1; i < arr.length; i++) {
        for (let j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            let temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
        console.log(arr);
    }
    return arr;
}
```

### 快速排序

> 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以[递归](https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695)进行，以此达到整个数据变成有序[序列](https://baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588)。
>
> 时间复杂度：O (nlogn)
>
> 最坏情况：O(n^2)

```javascript
function quick_sort(arr,from,to){
	var i = from; //哨兵i
	var j = to; //哨兵j
	var key = arr[from]; //标准值
	if(from >= to){ //如果数组只有一个元素
	   return;
	}
	while(i < j){
		while(arr[j] > key && i < j){ //从右边向左找第一个比key小的数，找到或者两个哨兵相碰，跳出循环
			j--;
		}
		while(arr[i] <= key && i < j){  //从左边向右找第一个比key大的数，找到或者两个哨兵相碰，跳出循环,这里的=号保证在本轮循环结束前，key的位置不变，否则的话跳出循环，交换i和from的位置的时候，from位置的上元素有可能不是key
			i++;
		}
		/**
		  代码执行道这里，1、两个哨兵到找到了目标值。2、j哨兵找到了目标值。3、两个哨兵都没找到(key是当前数组最小值)
		**/
		if(i < j){ //交换两个元素的位置
			var temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	arr[from] = arr[i] //
	arr[i] = key;
    quick_sort(arr,from,i-1);
	quick_sort(arr,i+1,to);
}
```

## 数组的去重

### 最简单的双层循环方法

> 在这个方法中，我们使用循环嵌套，最外层循环 array，里面循环 res，如果 array[i] 的值跟 res[j] 的值相等，就跳出循环，如果都不等于，说明元素是唯一的，这时候 j 的值就会等于 res 的长度，根据这个特点进行判断，将值添加进 res。

```javascript
var array = [1, 1, '1', '1'];

function unique(array) {
    // res用来存储结果
    var res = [];
    for (var i = 0, arrayLen = array.length; i < arrayLen; i++) {
        for (var j = 0, resLen = res.length; j < resLen; j++ ) {
            if (array[i] === res[j]) {
                break;
            }
        }
        // 如果array[i]是唯一的，那么执行完循环，j等于resLen
        if (j === resLen) {
            res.push(array[i])
        }
    }
    return res;
}
```

### 排序后去重

> 试想我们先将要去重的数组使用 sort 方法排序后，相同的值就会被排在一起，然后我们就可以只判断当前元素与上一个元素是否相同，相同就说明重复，不相同就添加进 res

```javascript
var array = [1, 1, '1'];

function unique(array) {
    var res = [];
    var sortedArray = array.concat().sort();
    var seen;
    for (var i = 0, len = sortedArray.length; i < len; i++) {
        // 如果是第一个元素或者相邻的元素不相同
        if (!i || seen !== sortedArray[i]) {
            res.push(sortedArray[i])
        }
        seen = sortedArray[i];
    }
    return res;
}
```

### indexOf

```javascript
var array = ['1','2',1,'1','4','9','1'];
function unique(array){
    var res=[];
    for(var i=0,len=array.length;i<len;i++){
        var current=array[i];
        if(res.indexOf(current)===-1)
        {
       	 res.push(current);
        }
    }
    return res;
}
console.log(unique(array));
```

### filter

```javascript
var array = [1, 2, 1, 1, '1'];

function unique(array) {
    return array.concat().sort().filter(function(item, index, array){
        return !index || item !== array[index - 1]
    })
}
console.log(unique(array));
```

### ES6的方法

```javascript
var array = ['1','2',1,'1','4','4','1'];
function unique(array) {
	// res用来存储结果
	return Array.from(new Set(array));
}
console.log(unique(array));
```



## 二分查找

```javascript
  // 有序的二分查找 返回-1 或存在的下标
        function binarySearch(target, arr) {
            var start = 0;
            var end = arr.length - 1;
            while (start < end) {
                var mid = parseInt(start + (end - start) / 2);
                if (target == arr[mid]) {
                    return mid;
                } else if (target < arr[mid]) {
                    end = mid - 1;
                } else if (target > arr[mid]) {
                    start = mid + 1;
                }
            }
            return -1;
        }
```

